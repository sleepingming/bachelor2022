\chapter{Имплементация протокола SRNS в RTKLIB}
\label{cha:simulation}

\section{Разработка программного модуля для приёма данных в виде пакетов}
Для начала необходимо создать алгоритм, способный обработать данные, полученные с приёмника в бинарном виде, и считать из файла необходимые параметры передаваемых пакетах. Для разработки будем использовать язык программирования C, т.к. на этом языке написан RTKLIB, а далее перед нами стоит задача внедрить разработанный алгоритм непосредственно в библиотеку.

\subsection{Ознакомление с описанием протокола SRNS}
\paragraph{Общее описание}

Протокол SRNS -- бинарный протокол обмена данными с навигационным трансивером и
управления им. Отличительная особенность протокола - непосредственная передача струк­тур данных, используемых внутренними блоками трансивера. Кроме того, поддерживается
смешивание потоков данных от нескольких источников.

\paragraph{Формат пакета данных}

Протокол предполагает передачу данных в виде пакетов. Все пакеты имеют стандартный
формат. Данные передаются в виде последовательности 32-разрядных слов, что совпадает с
разрядностью процессора и разрядностью регистров коррелятора.
\begin{longtable}[c]{|lll|}
	\caption{Формат пакета данных} \label{tab:formatsrns}\\
	\hline
	Поле & Объём (бит) & Содержимое \\
	\hline
	Преамбула & 16 & 0x5253 — “SR” \\
	Отправитель & 16 & sender \\
	Объём данных & 16 & paylSize \\
	Номер пакета & 12 & pktID \\
	Счетчик & 4 & pktCnt \\
	Данные & 32 × \textit{paylSize} & payload \\
	Контрольная сумма & 32 & см. п. 2.1.1.3 \\
	\hline
	Общая длина пакета & 32 × (\textit{paylSize} + 3) &  \\
	\hline
\end{longtable}
По умолчанию в качестве идентификатора sender используется значение 0x534E. Тогда,
преамбула и номер отправителя вместе образуют слово <<SRNS>>, что позволяет визуально по
бинарному потоку опознать протокол и убедиться в правильности работы порта.

Значение pktCnt инкрементируется при отправке каждого пакета, пробегая значения от
0 до 15. Это позволяет отсортировать пакеты по времени отправки при использовании сети
Ethernet.

Поле paylSize содержит объём поля payload в 32-битных словах, а поле payload, в свою очередь, содержит
передаваемые данные. Если объем передаваемых данных не кратен 32 битам, то остаткок
payload заполняется нулями до 32-битной границы. Полная длина пакета на 3 слова (12 байт)
больше, чем указано в поле paylSize.

\paragraph{Формирование контрольной суммы}

В настоящем протоколе используется алгоритм CRC-32. Данный алгоритм позволяет
обнаруживать все кратные ошибки с длиной блока до 32 бит подряд и большинство блочных
ошибок большего размера. Алгоритм основан на сдвиговом регистре с обратными связями.
На начало работы регистр инициализируется единицами. Используется инверсия выхода.

Обратные связи регистра описываются полиномом:
\begin{equation}
	x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^{9}+x^{8}+x^{6}+1
\end{equation}

Через сдвиговый регистр последовательно прогоняется весь сформированный пакет
начиная от преабмулы и заканчивая полем данных. Содержимое регистра на конец операции
заносится в поле контрольной суммы пакета.

\hypertarget{algorythm}{\paragraph{Процедура обнаружения пакета}}

Алгоритм приёма пакета имеет следующий вид:
\begin{itemize}
	\item при приёме данных во входном потоке байт осуществляется поиск заголовка пакета;
	\item считывается номер пакета и объём;
	\item проверяется контрольная сумма;
	\item если контрольная сумма совпала, пакет принят верно;
	\item если контрольная сумма не совпала, пакет принят неверно, осуществляется дальней­
	ший поиск преамбулы.
\end{itemize}

\paragraph{Подверженность пакетов изменениям}

Большинство пакетов непосредственно содержат структуры данных тех или иных под­систем приемника. С развитием этих подсистем возможны и изменения в представлении
данных, что влечет за собой изменения формата пакетов. Все пакеты отнесены к одной из
трех категорий по критерию вероятности их модификации в последующих версиях протокола:
\begin{itemize}
	\item “fixed” - формат пакета фиксирован
	\item “stable” - изменения формата маловероятны
	\item “unstable” - вероятность изменений формата высока
\end{itemize}

\paragraph{Базовые типы данных}

Все данные передаются в виде 32-разрядных слов. Архитектура системы — little endian,
младший байт идёт первым. Обозначения используемых типов данных приведены в таблице
2.2.
\begin{longtable}[c]{|p{9cm}|l|l|}
	\caption{Формат базовых типов данных} \label{tab:formatbase}\\
	\hline
	Поле & Знаковое число & Беззнаковое число \\
	\hline
	Целое, 8 р & sint8 & uint8 \\

	Целое, 16 р & sint16 & uint16 \\
	
	Целое, 32 р & sint32 & uint32 \\
	
	Плавающая точка, одинарная точность, 32 р & float & -- \\

	Плавающая точка, двойная точность, $\;\;\;$64 р & double & -- \\
	\hline
\end{longtable}

\paragraph{Базовые типы данных}

Помимо базовых типов, в данном описании применяются составные типы данных. Им
соответствуют упакованные “структуры“ на языке Си, используемые в программном обеспе­чении трансивера. Наиболее важные и часто встречаемые структуры - описание сигнала и
состояние канала\cite{srns}.

\subsection{Реализация алгоритма на языке С}

Алгоритм для приёма пакетов данных приведён в \hyperlink{algorythm}{п. 2.1.1.4.}. Следуя этому алгоритму составим программу на языке С. Код программы приведён в приложении~\ref{cha:appendix1}.
На данный момент функция для подсчёта контрольной суммы не составлена, соответственно, правильность приёма пакетов точно проверить мы не можем. Но мы можем сделать так, чтобы программа при нахождении преамбулы каждого пакета выводила непосредственно номер пакета, обрабатываемого в данный момент времени. На рис. 2.1 представлен вывод программы.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/outputpacket}
	\caption{Вывод программы}
	\label{fig:outputpacket}
\end{figure}

На рисунке видим, что программа выводит номера принятых пакетов и т.к. числа идут подряд, можно сделать вывод, что пакеты идентифицируются верно и их перебор осуществляется без пропусков.

Но всё же это не даёт нам полной уверенности в том, что все пакеты приняты без ошибок. Для того, чтобы убедиться в этом, необходимо составить функцию для расчёта контрольной суммы и внедрить её в наш программный модуль.

Из описания протокола SRNS известно, что для контрольной суммы используется алгоритм CRC-32, основанный на сдвиговом регистре с обратными связями. Нам известно, что в алгоритме используется инверсия выхода, а также нам известен полином, которым описываются обратные связи регистра. Функцию для расчёта контрольной суммы на языке С можно найти в открытом доступе в сети интернет (Приложение~\ref{cha:appendix2}). Данную функцию мы внедрим в наш программный модуль, учитывая известный нам полином. На рис. 2.2 представлен вывод программы вместе с функцией для расчёта контрольной суммы. Первое выведенное число -- контрольная сумма, рассчитанная функцией, а второе -- контрольная сумма, принятая из пакета.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/checksum}
	\caption{Вывод программы}
	\label{fig:checksum}
\end{figure}

Видим, что числа одинаковы, следовательно, можно сделать вывод, что пакеты принимаются верно.

Для ещё большей уверенности можем проверить результат с помощью онлайн-калькулятора контрольной суммы. Для этого мы можем открыть файл с нашими сырыми данными в шестнадцатеричном редакторе и увидеть данные непосредственно как последовательность байтов.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/srnsbin}
	\caption{Окно шестнадцатеричного редактора}
	\label{fig:srnsbin}
\end{figure}

Здесь мы также можем убедиться в том, что при переводе из шестнадцатеричного вида преамбула пакета и номер отправителя вместе образуют слово <<SRNS>>. 

Последние 4 байта перед началом следующего пакета хранят в себе контрольную сумму текущего пакета. После того, как мы идентифицировали пакет, мы можем взять набор последовательных байт, и вставить его в калькулятор подсчёта контрольной суммы.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/packet}
	\caption{Преобразование пакета}
	\label{fig:packet}
\end{figure}
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.9\textwidth]{inc/svg/modules/calccrc32}
	\caption{Результаты расчёта контрольной суммы}
	\label{fig:calccrc32}
\end{figure}

На рисунке 2.5 можем наблюдать результат расчёта контрольной суммы с помощью онлайн-калькулятора. Красным цветом выделены основные интересующие нас параметры: заданный полином с инверсией выхода и результирующее значение контрольной суммы в шестнадцатеричном виде.
\begin{longtable}[c]{|p{7cm}|l|}
	\caption{Результаты расчёта контрольной суммы} \label{tab:checksum}\\
	\hline
	Тип контрольной суммы & Результат \\
	\hline
	Принятая из пакета & 52 FD D0 6F \\
	
	 Рассчитанная калькулятором& 52 FD D0 6F  \\
	
	Рассчитанная функцией & 52 FD D0 6F  \\
	\hline
\end{longtable}
Исходя из таблицы 2.3 можно сделать вывод, что результаты всех видов расчётов сошлись, следовательно, пакеты принимаются верно и написанный нами программный модуль работает корректно.

\section{Внедрение модуля в RTKLIB}
Для начала необходимо ознакомиться со структурой обрабатывающего файла. В исходных кодах приложения находится файл <<nvs.c>>, отвечающий за парсинг данных по протоколу NVS BINR.

Из всех пакетов, принятых навигационным приёмником, особый интерес представляют только два следующих пакета: 0x00F5 — <<Измерения первичных навигационных параметров>>, 0x00F7 — <<Расширенные эфемериды>>. С помощью данных пакетов и осуществляется обработка данных и дальнейшее решение навигационной задачи.

Перед имплементацией протокола SRNS нужно ознакомиться с общими особенностями функционирования протокола BINR.

\subsection{Функционирование протокола BINR}

\paragraph{Общие положения}

При отсутствии отдельных условий время во всех пакетах представлено как UTC. Представление времени – количество
секунд (или миллисекунд) от начала недели. Началом недели считается 00 часов в ночь с
субботы на воскресенье.

Дата также представлена с учетом поясного времени в виде номера недели от
22.08.1999г по модулю 1024 (1024-я неделя будет 0-й, 1025-я - 1-й и т.д.). Отрицательный
номер недели информирует об отсутствии значения даты.

Координаты потребителя передаются и принимаются в системе координат,
выбранной потребителем, а высота -- над геоидом или эллипсоидом. При этом широта и
долгота выражены в радианах, а высота -- в метрах. Северная широта и восточная долгота
выражаются положительными числами, а южная широта и западная долгота -
отрицательными.

В прямоугольной проекции Гаусса-Крюггера используется система координат СК-42, а координаты передаются в виде:

вместо широты -- координата X в метрах,

вместо долготы -- координата Y, увеличенная на 500000, в метрах

плюс номер зоны, умноженный на 1000000.
\newline Например, если принята пара чисел

широта 5452812.5,

долгота 06417534.2,
\newline то это означает, что

номер зоны -- 06

X = 5452812.5 метров

Y = $417534.2-500000=-82465.8$ метров.

Использование прямоугольных пространственных координат может быть задано в
режиме работы протокола. В этом случае координаты передаются в метрах от центра
Земли:

вместо широты - координата X,

вместо долготы - координата Y,

вместо высоты - координата Z.
\newline Проекции скорости также передаются в прямоугольных пространственных координатах.
При задании проекции Гаусса-Крюггера в данном режиме используется система
координат СК-42.

Настройка поясного времени и системы координат для каждого протокола и порта
совершается отдельно.
После включения питания аппаратуры для протокола действуют следующие
настройки:

система координат -- WGS-84;

время -- по Гринвичу;

высота -- над уровнем моря (геоидом).

\paragraph{Используемые типы данных}

Используемые типы данных
Форматы используемых типов данных с плавающей точкой соответствуют стандарту
ANSI/IEEE Std 754 (Таблица 2.4).

Целочисленные типы со знаком представляются в дополнительном коде.

В типах данных, состоящих из нескольких байт, первыми передаются младшие
байты. В байте первым также передается младший бит.

Данные с этими типами передаются в том виде, в каком они находятся в машинной
памяти IBM-совместимых компьютеров, то есть передача данных осуществляется
младшими байтами вперед.

\begin{longtable}[c]{|p{2cm}|c|c|}
	\caption{Форматы типов данных в протоколе BINR} \label{tab:formatbinr}\\
	\hline
	Тип & Размер, бит & Диапазон значений \\
	\hline
	INT8U & 8 & 0..255 \\
	
	INT8S & 8 & $-128..127$ \\
	
	INT16U & 16 & 0..65,535 \\
	
	INT16S & 16 & $-32,768..32,767$ \\
	
	INT32U & 32 & 0..4,294,967,295 \\
	INT32S & 32 & 2,147,483,648..2,147,483,647 \\
	FP32 & 32 & $3.4\cdot10^{-38}..3.4\cdot10^{38}$ \\
	FP64 & 64 & $1.7\cdot10^{-308}..1.7\cdot10^{308}$ \\
	FP80 & 80 & $3.4\cdot10^{-4932}..3.4\cdot10^{4932}$ \\
	\hline
\end{longtable}

\paragraph{Контроль передачи информации}

Обработка пакетов производится в соответствии с описанием структуры данных
пакета. В режиме «формирование контрольной информации» производиться
дополнительный контроль содержимого пакета путем сравнения вычисленной и принятой
контрольной информации. В случае несовпадения контрольной информации пакет не
используется.

Помимо этого пакет должен содержать не выходящие за границы допустимые для
каждого поля данные. В противном случае поведение аппаратуры не определено

В качестве алгоритма проверки содержимого пакета применяется контроль
циклическим избыточным кодом (ЦИК или cyclical redundancy check), основанный на
делении и умножении многочленов.
В математическом виде, если представить набор данных D в виде многочлена по
степеням двойки можно записать:
\begin{equation}
	D = Q \cdot G + R,
\end{equation}
где G -- предварительно согласованный многочлен, называемый порождающим
многочленом, Q -- многочлен частное (отбрасывается за ненадобностью), R -- остаточный
многочлен, известный просто как ЦИК. Одно из важных свойств порождающих
многочленов заключается в том, что число разрядов в остатке непосредственно
определяется числом разрядов G. При выборе порождающего многочлена
руководствуются двумя соображениями: желательной разрядностью остатка и его
способностью выявлять ошибки.

В аппаратуре используется один из наиболее известных порождающих многочленов
CCITT-16 (MKKTT-16):
\begin{equation}
	x^{16}+x^{12}+x^{5}+1
\end{equation}

\paragraph{Циклограмма работы протокола}

Навигационные данные, передаваемые аппаратурой, привязаны к темпу решения
навигационной задачи ($1 \div 10$ Гц). Значения широты и долготы, содержащиеся в пакете N
и соответствующие метке времени N, представляют собой либо координаты, полученные
на предыдущем цикле, то есть ранее на интервал решения навигационной задачи, либо
экстраполированные на данный интервал координаты, в зависимости от типа пакета.
Значения составляющих скорости не экстраполируются.

Время реакции на установочные пакеты – не более 100 мс при отсутствии передачи
более высокоприоритетных пакетов. Пользователь не должен посылать тот же запрос не
получив ответной реакции от аппаратуры. Выдача пакетов, привязанных к темпу решения
навигационной задачи, начинается после окончания соответствующего интервала
решения в пределах 20 мс. Для пояснения вышесказанного, на рисунке 2.6 показана циклограмма работы протокола\cite{nvsbinrspec}.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.9\textwidth]{inc/svg/modules/cyclebinr}
	\caption{Циклограмма работы протокола}
	\label{fig:cyclebinr}
\end{figure}
\newpage
\paragraph{NVS BINR в RTKLIB}

Обрабатывающий файл <<nvs.c>> имеет в составе функции для  декодирования необходимых нам пакетов 0x00F5 и 0x00F7 -- <<decode\_xf5raw>> и <<decode\_xf7eph>> соответственно. В первой функции происходит определение навигационной системы исходя из уникального идентификатора, извлечённого из пакета, а также извлечение навигационных данных и заполнение их в таблиц <<obs>> и <<nav>>, описание которых приведено в главе 1.2. Во второй функции осуществляется декодирование расширенных эфемерид спутников. Разные навигационные системы используют свои модели движения спутников. От типа навигационной системы, определённого ранее, зависит выбор алгоритма для декодирования расширенных эфемерид.

\subsection{Приведение программного модуля к структуре библиотеки}
Разработанный нами алгоритм пока не соответствует такому виду обрабатывающего файла, который может распознать RTKLIB.

В обрабатывающем файле мы должны разработать функции <<input\_srns>> и <<decode\_srns>>, аналогичные функциям для обработки по протоколу NVS BINR. Эти функции принимают в качестве аргумента структуру <<raw\_t>>, хранящую в себе переменные для записи данных из принятых информационных пакетов. Состав структуры приведён в приложении~\ref{cha:appendix3}.

Функция <<input\_srns>> отвечает непосредственно за нахождение пакетов 0x00F5 и 0x00F7, среди всех принятых, и за заполнение переменных принятыми данными для их подготовки к декодированию. В приложении ~\ref{cha:appendix4} и ~\ref{cha:appendix5} содержится программный код с реализованными функциями <<decode\_srns>> и <<input\_srns>>.

\subsection{Работа с формой приложения}

После реализации соответствующих функций в обрабатывающем файле необходимо осуществить возможность выбора протокола SRNS в приложении RTKNAVI среди списка всех поддерживаемых форматов данных и связать написанные функции с кнопками на форме приложения.

Для этого нужно открыть форму приложения в виде программного кода и выяснить, каким именно образом различные параметры на неё выводятся. 

В исходных кодах приложения по пути <<app/rtknavi>> находится файл <<mondlg.cpp>>, отвечающий за заполнение форм приложения различными объектами и вывод на них соответствующих параметров. В данном файле нужно найти тот самый момент, когда происходит формирование выпадающего меню и заполнение элементов поддерживаемыми форматами. 

На рисунке 2.7 красной рамкой выделен цикл, в котором осуществляется заполнение элементов. Можем увидеть, что цикл перебирает элементы массива <<formatstrs>>, этот массив и содержит поэлементный список всех форматов, поддерживаемых RTKLIB. 
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.7\textwidth]{inc/svg/modules/mondlg}
	\caption{Исходные коды, отвечающие за заполнение форм приложения}
	\label{fig:mondlg}
\end{figure}

Начав поиск по всему проекту, можем найти место объявления массива <<formatstrs>>. Итак, в папке <<src>>  находим файл <<rtkcmn.c>> и, открыв его, видим место объявления искомого массива с форматами (рисунок 2.8). К этому списку необходимо добавить <<SRNS>>.

Теперь массив, представленный на рисунке 2.7 выводит на форму слово <<SRNS>>, но пока это не подкреплено никаким функционалом. Для этого нам нужно осуществить вызов функции обработки при выборе соответствующего формата из выпадающего меню.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.6\textwidth]{inc/svg/modules/formats}
	\caption{Массив поддерживаемых форматов}
	\label{fig:formats}
\end{figure}

В проекте находим файл <<rcvraw.c>>, также находящийся в папке <<src>>. В нём видим функцию <<input\_raw>>, которая вызывает соответствующую функцию обработки при различных выборах используемого формата. Каждому формату соответствует свой идентификатор, соответственно для протокола SRNS нужно добавить аналогичный.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.6\textwidth]{inc/svg/modules/inputraw}
	\caption{Вызов функций при выборе соответствующего формата}
	\label{fig:inputraw}
\end{figure}

Теперь при выборе <<SRNS>> на форме приложения RTKNAVI вызывается функция <<input\_srns>> и можно считать, что функционал обработки данных полностью налажен.

\chapter{Испытания работы программного модуля}
\label{cha:testing}
\section{Обработка принятых пакетов в составе файла}

Для вывода основных параметров и получения решения навигационной задачи можем обойтись только лишь RTKNAVI, минуя остальные приложения.

Имеем файл <<SRNS\_SIM.BIN>> с записанными пакетами с навигационного приёмника. Подадим этот файл на вход приложения RTKNAVI и в списке поддерживаемых форматов выберем SRNS. После нажатия кнопки <<Start>> можем увидеть, что приложение получает решение навигационной задачи, а также выводит таблицы с соответствующими навигационными параметрами.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.6\textwidth]{inc/svg/modules/srnswindow}
	\caption{Окно настроек входного потока RTKNAVI}
	\label{fig:srnswindow}
\end{figure}
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/srnssolv}
	\caption{Решение навигационной задачи}
	\label{fig:srnssolv}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/srnssat}
	\caption{Расположение спутников}
	\label{fig:srnssat}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/srnsobs}
	\caption{Данные наблюдений}
	\label{fig:srnsobs}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/srnsnavgps}
	\caption{Параметры спутников GPS}
	\label{fig:srnsnavgps}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/srnsnavglo}
	\caption{Параметры спутников ГЛОНАСС}
	\label{fig:srnsnavglo}
\end{figure}

\
\section{Обработка данных, принимаемых с приёмника в реальном времени}
\subsection{Описание лабораторной установки}
Для проверки корректности работы нашего программного модуля будем использовать конфигурацию, состоящую из навигационного приёмника и имитатора сигналов SMBV100A.

Имитатор сигналов -- прибор, позволяющий генерировать определённые навигационные сигналы для приёмника. Используется для имитации сигналов глобальных навигационных спутниковых систем(GPS, ГЛОНАСС, BeiDou, Galileo). В состав испытательной установки входит векторный генератор Rohde\&Schwarz SMBV100A, изображённый на рисунке 3.1.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/smbv}
	\caption{Векторный генератор сигналов Rohde\&Schwarz SMBV100A}
	\label{fig:smbv}
\end{figure}

Данный прибор позволяет осуществлять перенос сигналов модуляции (аналоговых или цифровых) на ВЧ и вывод итогового сигнала, при этом, сигнал модуляции формируется в цифровой форме и обрабатывается как поток комплексных I/Q-данных в полосе частот модулирующего сигнала.

Rohde\&Schwarz SMBV100A может использоваться для имитации определенных
навигационных радиосигналов для приемника воздействия, а наличие LAN-
интерфейса позволяет производить удаленную (по протоколу TCP/IP)
настройку прибора для формирования сигналов заданной ГНСС.
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/struct}
	\caption{Структурная схема испытательной установки}
	\label{fig:struct}
\end{figure}
\subsection{Ход испытания}

Сначала необходимо настроить имитатор Rohde\&Schwarz SMBV100A:
\begin{itemize}
	\item Включить прибор
	\item Привести устройство к настройкам по умолчанию
	\item Задать параметры сигнала GPS
	\item Задать параметры сигнала ГЛОНАСС
	\item Задать координаты г. Москвы
	\item Настроить группировку спутников
\end{itemize}
\begin{figure}[ht]
	\centering
	\includegraphics[keepaspectratio, width=0.5\textwidth]{inc/svg/modules/smbv1}
	\caption{Окно настройки параметров GPS}
	\label{fig:smbv1}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.5\textwidth]{inc/svg/modules/smbv2}
	\caption{Окно настройки имитируемой позиции}
	\label{fig:smbv2}
\end{figure}
\newpage
После обозначения имитируемой позиции необходимо настроить группировку спутников. Теперь мы можем наблюдать на экране имитатора расположение спутников, где R -- спутники ГЛОНАСС, G -- спутники GPS. Далее полученную картинку мы сможем сравнить с той, которую получит RTKLIB.
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.7\textwidth]{inc/svg/modules/smbv3}
	\caption{Окно настройки группировки спутников}
	\label{fig:smbv3}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.7\textwidth]{inc/svg/modules/smbv4}
	\caption{Расположение спутников в SMBV100A}
	\label{fig:smbv4}
\end{figure}
\newpage
Теперь необходимо подключиться навигационному приёмнику с помощью сервера. Для этого нужно в RTKNAVI с помощью настроек <<Input>> выбрать подключение в качестве клиента по TCP/IP. Ввести данные сервера и порт и нажать <<Start>>.
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.9\textwidth]{inc/svg/modules/labsolv}
	\caption{Решение навигационной задачи}
	\label{fig:labsolv}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.9\textwidth]{inc/svg/modules/labsat}
	\caption{Расположение спутников}
	\label{fig:labsat}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/labobs}
	\caption{Данные наблюдений}
	\label{fig:labobs}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/labnavgps}
	\caption{Параметры спутников GPS}
	\label{fig:labnavgps}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.8\textwidth]{inc/svg/modules/labnavglo}
	\caption{Параметры спутников ГЛОНАСС}
	\label{fig:labnavglo}
\end{figure}
\clearpage

Из приведённых выше рисунков можно увидеть, что программа функционирует и предоставляет решение навигационной задачи в реальном времени. В силу того, что мы подключены к навигационному приёмнику напрямую, решение НЗ и навигационные данные периодически меняются. Из данных наблюдений видим, что отображаемые даты совпадают с заданными в настройках имитатора.
\subsection{Использование GNSS Planning}
Trimble GNSS Planning -- онлайн-программа, позволяющая определить основные характеристики спутникового GNSS покрытия. Для работы с данной утилитой достаточно ввести координаты места, дату и промежуток времени, при чём ввод координат доступен как вручную, так и графически, с помощью отметки точки на карте. В программе также имеется возможность просматривать хронологию, т.е. с помощью бегунка можно увидеть местоположение спутников и их орбиты в каждый момент определённого интервала времени. Также программа умеет строить различные зависимости: число видимых спутников в каждый момент времени, возвышения спутников, PDOP  другие.

Для проверки данных, полученных RTKLIB, зададим в приложении GNSS Planning настройки, идентичные настройкам имитатора.
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=1\textwidth]{inc/svg/modules/planningopt}
	\caption{Настройка параметров GNSS Planning}
	\label{fig:planningopt}
\end{figure}

После указания всех необходимых данных мы можем увидеть, где находились спутники различных навигационных систем в данный момент времени относительно указанных координат точки. В плане навигационных систем нас сейчас интересуют только GPS и ГЛОНАСС.
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.6\textwidth]{inc/svg/modules/planningsat}
	\caption{Расположение спутников}
	\label{fig:planningsat}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio, width=0.9\textwidth]{inc/svg/modules/planningmap}
	\caption{Расположение спутников на карте}
	\label{fig:planningmap}
\end{figure}

Сравнив рисунки 3.19 и 3.14, можем увидеть, что расположения спутников, полученные с помощью GNSS Planner и RTKLIB совпадают. Исходя из этого можем сделать вывод, что наш программный модуль работает корректно.